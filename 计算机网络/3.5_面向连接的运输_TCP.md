### 3.5.1 TCP连接

TCP被称为是**面向连接的**（connection-oriented）,这是因为在一个应用进程可以开始向另一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互‘握手’，即它们必须相互发送某些预备报文段，以建立确保数据传输的参数。作为TCP建立连接的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量。

TCP连接是**点对点**（point-to-point）的，即在单个发送方与单个接收方之间的连接。

客户首先发送一个特殊的TCP报文段，服务器用另一个特殊的TCP报文段来响应，最后，客户再用第三个特殊报文段作为响应。前两个报文段不承载‘有效载荷’，也就是不包含应用层数据；而第三个报文段可以承载有效载荷。由于在这两台主机之间发送了3个报文段，所以这种连接建立过程常被称为**三次握手**（three-way handshake）

一旦建立起一条TCP连接，两个应用进程之间就可以相互发送数据了。

客户进程通过套接字传毒数据流，数据一旦通过套接字，就由客户中运行的TCP控制了。TCP将这些数据引导到该连接的**发送缓存**（send buffer）里，发送缓存是发起三次握手期间设置的缓存之一。接下来TCP就会不时地从发送缓存中取出一块数据，并将数据传递到网络层。

TCP可以从缓存中取出并放入报文段中的数据数量受限于**最大报文段长度**（Maximum Segment Size, MSS）.MSS通常根据最初确定的由本地主机发送的最大链路层帧长度（即**最大传输单元**（Maximum Transmission Unit, MTU）)来设置。

TCP为每块客户数据配上一个TCP首部，从而形成多个**TCP报文段**（TCP segment）。这些报文段被下传给网络层，网络层将其分别封装在网络层IP数据报中。然后这些IP数据报被发送到网络中。当TCP在另一端接收到一个报文段后，该报文段的数据就被放入该TCP连接的接收缓存中。

TCP连接的组成包括：一台主机上的缓存、变量和与进程连接的套接字，以及另一台主机上的另一组缓存、变量和与进程连接的套接字。

### 3.5.2 TCP报文段结构

TCP的首部一般是20字节（比UDP首部多12字节）

首部包括：
+ **源端口号**和**目的端口号**，被用于多路复用/分解来自或发送到上层应用的数据。
+ **检验和**，检查比特错误。
+ 32比特的**序号字段**（sequence number field）和32比特的**确认号字段**（acknowledgment number field）：这些字段被TCP发送方和接收方用来实现可靠数据传输服务。
+ 16比特的**接收窗口字段**（recieve window field），该字段用于流量控制。该字段用于指示接收方愿意接收的字节数量。
+ 4比特的**首部长度字段**（header length field），该字段指示了以32比特的字为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。（通常，选项字段为空，所以TCP首部的典型长度是20字节）
+ 可选与变长的**选项字段**（option field），该字段用于发送方和接收方协商最大报文段长度（MSS）时，或在高速网络环境下用作窗口调节因子时使用。首部字段中还定义了一个时间戳选项。
+ 6比特位的**标志字段**（flag field）。（CWR,ECE,URG,ACK,PSH,RST,SYN,FIN）**ACK比特**用于指示确认字段中的值是有效的，即该报文段包括一个对已被成功接收报文段的确认。**RST**、**SYN**和**FIN**比特用于连接建立和拆除。在明确拥塞通告中使用了**CWR**和**ECE**比特。当**PSH比特**被置位时，就指示接收方应立即将数据交给上层。**URG比特**用来指示报文段里存在着被发送端的上层体置为‘紧急’的数据。紧急数据中的最后一个字段由16比特的**紧急数据指针字段**（urgent data pointer field）指出。当紧急数据存在并给出指向紧急数据尾指针的时候，TCP必须通知接收端的上层实体（在实践中，PSH、URG和紧急数据指针并没有使用。）

#### 1 序号和确认号

TCP把数据看成一个无结构的、有序的字节流。

序号是建立在传送的字节流之上，而不是建立在传送的报文段的序列之上。一个**报文段的序号**（sequence number for a segment）因此是该报文段首字节的字节流编号。

TCP是双全工的，因此主机A在向主机B发送数据的同时，也许也接收来自主机B的数据（都是同一条TCP连接的一部分）。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号。

TCP提供**累积确认**（cumulative acknowledgment），即TCP报文段中的确认号只确认流中至第一个丢失字节为止的字节。

#### 2 Telnet 序号和确认号的一个学习案例

### 3.5.3 往返时间的估计与超时

TCP采用超时/重传机制来处理报文段的丢失问题。

#### 1 估计往返时间

报文段的样本RTT（SampleRTT）就是从某报文段被发出到对该报文的确认被收到之间的时间量。

**指数加权移动平均**（Exponential Weighted Moving Average， EWMA）

TCP维持一个SampleRTT均值(EstimateRTT)，当一旦获得一个新的SampleRTT时，就更新EstimateRTT

`EstimateRTT = (1 - α) * EstimateRTT + α * SampleRTT`

α推荐为0.125

RTT偏差DevRTT，用于估算SampleRTT一般会偏离EstimateRTT的程度

`DevRTT = (1 - β) * DevRTT + β * | SampleRTT - EstimateRTT |`

β推荐为0.25

#### 2 设置和管理重传超时间隔

`TimeoutInterval = EstimatedRTT + 4 * DevRTT`

推荐的TimeoutInterval为1s。同时，当出现超时后，TimeoutInterval将加倍，以免即将被确认的后继报文段过早出现超时。然而，只要收到报文段并更新EstimatedRTT，就使用上述公式再次计算TimeoutInterval

### 3.5.4 可靠数据传输

### 3.5.5 流量控制

TCP为它的应用程序提供了**流量控制服务**（flow-control service）以清除发送方使接收方缓存溢出的可能性。流量控制因此是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读取速率相匹配。

TCP通过让接收方维护一个称为**接收窗口**（recieve window）的变量类提供流量控制。通俗地说，接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。

TCP规范中要求：当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段。这些报文段将会被接收方确认。最终缓存将开始清空，并且确认报文段里将包含一个非0的rwnd（接受窗口值）值。

### 3.5.6 TCP连接管理

+ 第一步：客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文段。该报文段中不包含应用数据。但是在报文段的首部中的一个标志位（即SYN比特）被置为1。因此，这个特殊报文段被称为SYN报文段。另外，客户会随机选择一个序号并置于报文段的序号字段中。
+ 第二步：一旦包含TCP SYN报文段的IP数据报到达服务器主机，服务器会从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用数据。该允许连接的报文段被称为SYNACK报文段。
+ 第三步：在收到SYNACK报文段后，客户也要给该连接分配缓存和变量。客户主机则向服务器发送另一个报文段；这最后一个报文段对服务器的允许连接的报文段进行了确认。该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。

为了创建该连接，在两台主机之间发送了3个分组，因此，这种连接创建过程通常被称为**三次握手**（three-way handshake）

参与一条TCP连接的两个进程中的任何一个都能终止该连接。当连接结束后，主机中的资源将被释放。如，客户端准备关闭连接，那么，客户应用进程发出一个关闭连接命令。客户TCP向服务器进程发送一个特殊的报文段，首部标志位FIN被置为1.当服务器接收到该报文段后，将向发送方发送一个确认报文段。然后，服务端发送它自己的终止报文段，最后，该客户对服务器的终止报文段进行确认。此时，在两台主机上用于该连接的所有资源都被释放了。

【开始建立连接是三次握手，最后终止连接是四次挥手】