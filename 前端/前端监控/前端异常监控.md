珠玉在前：[前端异常监控解决方案研究](https://cdc.tencent.com/2018/09/13/frontend-exception-monitor-research/)

一个监控系统大概分为四个阶段：日志采集、日志存储、统计与分析、报告和警告
1. 采集阶段：收集异常日志，先在本地做一定的处理，再采取一定的方案上报到服务器
2. 存储阶段：后端接收前端上传的异常日志，经过一定处理，按照一定的存储方案存储
3. 分析阶段：分为机器自动分析与人工分析。机器自动分析，根据预设的条件与算法，对存储的日志信息进行统计与筛选，发现问题，触发告警。人工分析，通过提供可视化数据面板，让系统用户可以看到具体的日志数据，根据信息，发现异常数据根源。
4. 报警阶段：分为告警和预警。告警按照一定的级别自动报警，通过设定的渠道，按照一定的触发规则进行。预警则在异常发生前，提前预判，给出警告。

## 1 前端异常

前端异常是指在用户使用Web应用时无法快速得到符合预期结果的情况，不同的异常带来的后果程度不同，轻则引起用户使用不悦，重则导致产品无法使用，使用户丧失对产品的认可

### 1.1 前端异常分类

根据异常代码的后果的程度，对前端异常的表现分为如下几类：出错、呆滞、损坏、假死、崩溃。

### 1.2 异常错误原因分类

#### 1.2.1 逻辑错误

**频率：经常**
1. 业务逻辑判断条件错误
2. 事件绑定顺序错误
3. 调用栈时序错误
4. 错误的操作js对象

#### 1.2.2 数据类型错误

**频率：经常**
1. 将null视作对象读取property
2. 将undefined视作数组进行遍历
3. 将字符串形式的数字直接用于加计算
4. 函数参数未传递

#### 1.2.3 语法句法错误

**频率：较少**

#### 1.2.4 网络错误

**频率：偶尔**
1. 响应慢
2. 服务端未返回数据但状态码显示200，前端按正常进行数据遍历
3. 提交数据时网络中断
4. 服务端500错误时前端未作任何错误处理

#### 1.2.5 系统错误

**频率：较少**
1. 内存不足
2. 磁盘不足
3. 壳不支持API
4. 不兼容

## 2 异常采集

### 2.1 采集内容

> 四w原则：WHO did WHAT and get WHICH exception in WHICH environment?

#### 2.1.1 用户信息

出现异常时该用户的信息，例如该用户在当前时刻的状态、权限等，以及需要区分用户可多终端登录时，异常对应的是哪一个终端。

#### 2.1.2 行为信息

用户进行什么操作时出现了异常，所在的界面路径；执行了什么操作；操作时使用了哪些数据；当时的API吐了什么数据给客户端；如果是提交操作，提交了什么数据；上一个路径；上一个行为日志记录等。

#### 2.1.3 异常信息

产生异常的代码信息：用户操作的DOM元素节点；异常级别；异常类型；异常描述；代码stack信息等。

#### 2.1.4 环境信息

网络环境；设备型号和标识码；操作系统版本；客户端版本；API接口版本等。

| 字段	| 类型	| 解释 |
| -	| -	| - |
| 字段	| 类型	| 解释 |
| requestId | String | 一个界面产生一个requestId |
| traceId | String | 一个阶段产生一个traceId，用于追踪和一个异常相关的所有日志记录 |
| hash | String | 这条log的唯一标识码，相当于logId，但它是根据当前日志记录的具体内容而生成的 |
| time | Number | 当前日志产生的时间（保存时刻） |
| userId | String |  |
| userStatus | Number | 当时，用户状态信息（是否可用/禁用） |
| userRoles | Array | 当时，前用户的角色列表 |
| userGroups | Array | 当时，用户当前所在组，组别权限可能影响结果 |
| userLicenses | Array | 当时，许可证，可能过期 |
| path | String | 所在路径，URL |
| action | String | 进行了什么操作 |
| referer | String | 上一个路径，来源URL |
| prevAction | String | 上一个操作 |
| data | Object | 当前界面的state、data |
| dataSources | Array\<Object> | 上游api给了什么数据 |
| dataSend | Object | 提交了什么数据 |
| targetElement | HTMLElement | 用户操作的DOM元素 |
| targetDOMPath | Array\<HTMLElement> | 该DOM元素的节点路径 |
| targetCSS | Object | 该元素的自定义样式表 |
| targetAttrs | Object | 该元素当前的属性及值 |
| errorType | String | 错误类型 |
| errorLevel | String | 异常级别 |
| errorStack | String | 错误stack信息 |
| errorFilename | String | 出错文件 |
| errorLineNo | Number | 出错行 |
| errorColNo | Number | 出错列位置 |
| errorMessage | String | 错误描述（开发者定义） |
| errorTimeStamp | Number | 时间戳 |
| eventType | String | 事件类型 |
| pageX | Number | 事件x轴坐标 |
| pageY | Number | 事件y轴坐标 |
| screenX | Number | 事件x轴坐标 |
| screenY | Number | 事件y轴坐标 |
| pageW | Number | 页面宽度 |
| pageH | Number | 页面高度 |
| screenW | Number | 屏幕宽度 |
| screenH | Number | 屏幕高度 |
| eventKey | String | 触发事件的键 |
| network | String | 网络环境描述 |
| userAgent | String | 客户端描述 |
| device | String | 设备描述 |
| system | String | 操作系统描述 |
| appVersion | String | 应用版本 |
| apiVersion | String | 接口版本 |

### 2.2 异常捕获

前端捕获异常分为全局捕获和单点捕获，全局捕获代码集中，易于管理；单点捕获作为补充，对某些特殊情况进行捕获，但分散，不利于管理。

#### 2.2.1 全局捕获

通过全局的接口，将捕获代码集中写在一个地方，可以利用如下接口：
+ window.addEventListener('error') / window.addEventListener('unhandledrejection') / document.addEventListener('click') 等
+ 框架级别的全局监听，例如aixos中使用interceptor进行拦截，vue、react都有自己的错误采集接口
+ 通过对全局函数进行封装包裹，实现在在调用该函数时自动捕获异常
+ 对实例方法重写（Patch），在原有功能基础上包裹一层，例如对console.error进行重写，在使用方法不变的情况下也可以异常捕获

#### 2.2.2 单点捕获

在业务代码中对单个代码块进行包裹，或在逻辑流程中打点，实现有针对性的异常捕获。

+ try...catch
+ 专门写一个函数来收集异常信息，在异常发生时，调用该函数
+ 专门写一个函数来包裹其他函数，得到一个新函数，该新函数运行结果和原函数一摸一样，只是在发生异常时可以捕获异常。

### 2.3 跨域脚本异常

方案一：
+ 将js内联到HTML中
+ 将js文件与HTML放在同域下

方案二：
+ 为页面上script标签添加crossorigin属性
+ 被引入脚本所在服务端响应头中，增加 Access-Control-Allow-Origin 来支持跨域资源共享

### 2.4 异常录制

对于一个异常，仅仅拥有该异常的信息还不足以完全抓住问题的本质，因为异常发生的位置，并不一定是异常根源所在的位置。我们需要对异常现场进行还原，才能复原问题全貌，甚至避免类似问题在其他界面中发生。这里需要引进一个概念，就是“异常录制”。录制通过“时间”“空间”两个维度记录异常发生前到发生的整个过程，对于找到异常根源更有帮助。

当异常发生时，异常的根源可能离我们很远，我们需要回到异常发生的现场，找到异常根源。就像现实生活中破案一样，如果有监控摄影机对案发过程的录影，对破案来说更加容易。如果仅仅关注异常本身，要找到异常的根源，需要凭借运气，但有了异常录制的帮助，找到根源就更加容易。

所谓的“异常录制”，实际上就是通过技术手段，收集用户的操作过程，对用户的每一个操作都进行记录，在发生异常时，把一定时间区间内的记录重新运行，形成影像进行播放，让调试者无需向用户询问，就能看到用户当时的操作过程。

用户在界面上的操作产生的events和mutation被产品收集起来，上传到服务器，经过队列处理按顺序存放到数据库中。当需要进行异常重现的时候，将这些记录从数据库中取出，采用一定的技术方案，顺序播放这些记录，即可实现异常还原。


### 2.5 异常级别

未完待续~